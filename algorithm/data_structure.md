数据结构
========
> 基本概念（时间、空间负责度）、数组、链表、堆栈、队列、二叉树、排序、其他常见算法
<!-- GFM-TOC -->
* [一、基本概念](#一、基本概念)
    * [1.时间复杂度](#1.时间复杂度)
    * [2.空间复杂度](#2.空间复杂度)
* [二、数组](#二、数组)
    * [1.概念及性质](#1.概念及性质)
    * [2.相关题目](#2.相关题目)   
* [三、链表](#三、链表)
    * [1.概念及性质](#1.概念及性质)
    * [2.相关题目](#2.相关题目)   
* [四、堆栈](#四、堆栈)
    * [1.概念及性质](#1.概念及性质)
    * [2.相关题目](#2.相关题目)   
* [五、队列](#三、链表)
    * [1.概念及性质](#1.概念及性质)
    * [2.相关题目](#2.相关题目)     
* [六、二叉树](#六、二叉树)
    * [1.概念及性质](#1.概念及性质)
    * [2.相关题目](#2.相关题目)   
 * [七、排序](#七、排序)
    * [1.分类](#1.分类)   
    *  [2.稳定性](#1.稳定性)   
 * [八、其他常见算法](#八、其他常见算法)
   
<!-- GFM-TOC -->
# 一、基本概念
## 1.时间复杂度
> 渐进时间复杂度，标识算法运行时间与输入值大小的关系，忽略低阶项目，采用O（f(n)）表示法，一般分为：
> O(1)、 O(lgN)、O(N)、 O(nLgN）、O(N2)、O(N3)....
> 计算时间复杂度 ≈ “进行的循环趟数”
##  2.空间复杂度
>算法执行需要的额外空间。
# 二、数组
## 1.概念及性质
> 一组同类型的连续数据
> 数组最大的优点是**可以通过下标直接访问**， 即可以直接寻址。一般排序算法也都使用**数组**作为数据结构

## 2. 相关题目
1. 获取数组中的最大（最小元素）
> eg : [1, 2 -1, 5, 3] 的最大值和最小值分别为 5和-1
> 定义变量，遍历过程中不断更新该变量
2.  获取某个数组中出现最多的元素
> eg:  [1, 2, 3, 3, 5, 3] 中出现最多的元素， 结果为 3 
> 定义map, key为元素内容，value为出现频次
3. 求整型数组中和为target的数对。
> eg: 给定数组 [4、2、1、7、11、15], target 为15， 求结果为15的结果对（必须为两个数之和）， 结果为  4和11。
> Solution 1 :  建立一个map, key为元素值，val = target - arr[i]。 建立map后遍历原数组，如果map[val] =  arr[i], 则val 和 arr[i] 为一对可选值， 时间复杂度O(n), 空间复杂度O(n)。
> Solution 2 ：先对数组排序，之后分别从前后两端遍历数组，如果 arr[i] + arr[j] = target, 则为一个可选结果。时间负责度为O(NlgN)，即排序时间复杂度，空间复杂度为O(1)。
* 查询给定元素是否在有序数组中- 即 **二分搜索**
> eg:  查询 1 是否在  [1、2、4、5、7、11、15] 中
> 
> Solution : 每次取数组中间的元素和目标值比较，确定目标值可能在上半区还是下半区。同目标值相等时返回true, 右边下标小于左边下标是返回false 
> 
> 延伸： **求一个正数的开根号**，也采用二分搜索，注意区分输入值大于1 或者小于 1 的情况（两种情况正好相反，*小于1的时候越乘越小，大于1的时候越乘越大*）。
> 二分搜索的时间复杂度为O(lgN)
4. 最大子数组和
> 一个整形数组中包含负整数，求最大连续子数组和,经典的动态规划
```
//全部是负数就返回0了
//定义以当前元素为结尾的最大字数组和为curMax[i], 则有curMax[i] = max{curMax[i - 1], 0} + arr[i]
//因为只需要保留上一元素的历史状态，这里只需要定义一个变量就好了，不需要定义数组
public int maxSubArr(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int curMax = Math.max(0, arr[0]);
    int max = curMax;
    for (int i = 1; i < arr.length; i++) {
        curMax = Math.max(0, curMax) + arr[i];
        if (curMax > max) {
            max = curMax;
        }
    }
    return max;
}
```
# 三、链表
## 1.概念及性质

> 一组通过指针相连，物理存储上不一定连续的数据结构。只可以通过next指针或者pre指针进行元素的访问
> 最大特点是**物理空间非必须连续**， 分配空间灵活，适合**插入**或者**删除**,  不适合访问特定元素，需要遍历 。
## 2. 相关题目

 1. 遍历链表、插入节点到指定节点、删除节点(基本)
 2. 判断链表是否存在*环路*
> **快慢指针法**， 两个指针，一个指针每次走两步，一个指针每次走一步，同时开始遍历，若存在环路，则两个指针必定相遇
 3. 两个链表是否存在交点
> 存在交点的链表类似一个*拉链*， 将其中一个链表首尾相接，则转换为**链表含环**的问题
 4. 求链表的倒数第k个节点
> **快慢指针法**，一个指针先走k步之后，另外一个指针从头开始和快指针共同遍历，快指针走完的时候，慢指针走到倒数第K个节点
 5. 链表逆置
>  Solution1: 重新分配空间，遍历过程中简历前后关系，不过不友好，而且空间复杂度为O(n)
>  Solution2: 原地逆置，保证**链表不断**即可，修改指针前将next保存到临时变量

# 四、堆栈
## 1.概念及性质

>  堆栈定义：先入后出
>  函数定义、递归等都是堆栈操作
## 2. 相关题目
1. 括号匹配
> eg： 给出一个字符串由，*"{}()"* 组成，检查括号是否匹配
> 
> Solution: 建立堆栈，遇到左括号压入栈，右括号检查栈顶元素是否和当前括号匹配，匹配则弹出元素，最终栈空则整体匹配，否则不匹配。
> 
> Ps：这道题还有个update版本，求**计算带括号的四则运算**，用两个栈，操作数栈和操作符栈，涉及到算数符号的优先级还是有点难度的。。。
2. 二叉树非递归遍历（前中后三序）
> 有些难，有空补代码
3. 用两个栈实现一个队列
> 难。。。Talk is cheap, show me the code
```
//两个栈，一个用做push,另一个用作pop，
//当pop栈没有数据时，将push栈的数据全部读出后push到pop栈，之后读pop栈
//关键在于，一个只做pop, 另一个只做push
public class QueueWithStack<Integer>{
    Stack<Integer> pushStack = new Stack();
    Stack<Integer> popStack = new Stack();

     Integer push(Integer i) {
         return pushStack.push(i);
    }

     Integer pop() {
        if (popStack.isEmpty()) {
            while (!pushStack.isEmpty()) {
                popStack.push(pushStack.pop());
            }
        }
        return popStack.pop();
    }
}
```

# 五、队列
## 1.概念及性质

>  定义：先入先出
## 2. 相关题目
1. 二叉树的分层遍历
>  用队列来实现，不太好描述

# 六、二叉树
## 1.概念及性质

>  定义：含有根、左节点、右节点的数据结构，左右节点分别也是二叉树
>  
>  二叉树的高度：从根节点到叶子节点的最长路径
>  满二叉树：所有的叶子节点在同一层的二叉树
>   完全二叉树：
>   前序遍历： 根 左 右
>   中序遍历： 左 中 右
>   后序遍历： 左 右 根
>   搜索二叉树： 左节点 < 根节点 < 右子节点, 中序遍历后是一个递增序列
## 2. 相关题目
1. 前中后三序遍历
>  递归
>  非递归
>  所有有关二叉树的题目都是遍历
2. 求二叉树的高度
> 递归求左子树高度和右子树高度，height = Max(left, right) + 1 
```
//树结构
static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
}
//求树高度, 左右子树比较高
int getTreeHeight(TreeNode treeNode) {
    if (treeNode == null) return 0;
    return Math.max(getTreeHeight(treeNode.left), getTreeHeight(treeNode.right)) + 1;
}
```
3. 求两个节点的最近公共祖先节点
>  从根节点分别求到两个节点的路径序列，然后求两个路径的前缀即可

# 七、排序
## 1.排序分类

|排序算法 |空间复杂度| 时间复杂度| 稳定性|
|--|--|--|--|
|冒泡排序  | O(1) |O(N2)  | 稳定
|选择排序  | O(1) |O(N2)  | 不稳定
|插入排序  | O(1) |O(N2)  | 稳定
|希尔排序  | O(1) |> O(N), < O(N2)   | 不稳定
|归并排序  | O(N) |O(NlogN) | 不稳定
|快排  | O(LogN) |O(NlogN) | 稳定
|堆排  | O(N) |O(NlogN) | 不稳定
## 2. 排序算法的稳定性
> 稳定性： 经过排序之后相同关键因子值的元素是否相对位置保持不变

# 八、其他常见算法
1. 上楼梯问题
> 上n级台阶，每次可以走一步或者两步，问走上楼梯总共多少种走法
>
>是个斐波那契数列问题， f(n) = f(n-1) + f(n - 2), 还可以有优化方案，就是动态规划的思想，用两个变量记录下 f(n - 1) , f(n - 2) ，然后计算出f(n), 之后更新变量。
2. 8个球，有一个球比较轻，一个天平最少几次可以称出来轻球
> 三分搜索，答案是两次  